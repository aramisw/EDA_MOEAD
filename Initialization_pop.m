%% Project: EDA_MOEAD
%Author: Wang Zhao
%Date: 20170103
%Status: Programming

%%
function pop_array=Initialization_pop(amount_pop,area_x,area_y,amount_airship,amount_neighbor)
%Description: This function initialize the pop_array

%ATTENTION
% In this program, all the data is in the following form. The item is
% according to the column and the data is according to the row

%Struct declaration
pop_array_field_1=...
    {...
    'obj_1';...
    'obj_2';...
    'pst_x_1';...
    'pst_y_1';...
    'pst_x_2';...
    'pst_y_2';...
    'w1';...
    'w2';...
    'nb';...
    'obj_norm_1';...
    'obj_norm_2';...
    'obj_decomp';...
    'obj_past_1';...
    'obj_past_2'...
    };

%Population Initialization
pop_array=struct(...
    pop_array_field_1{1},cell(1,amount_pop),...
    pop_array_field_1{2},cell(1,amount_pop),...
    pop_array_field_1{3},cell(1,amount_pop),...
    pop_array_field_1{4},cell(1,amount_pop),...
    pop_array_field_1{5},cell(1,amount_pop),...
    pop_array_field_1{6},cell(1,amount_pop),...
    pop_array_field_1{7},cell(1,amount_pop),...
    pop_array_field_1{8},cell(1,amount_pop),...
    pop_array_field_1{9},cell(1,amount_pop),...
    pop_array_field_1{10},cell(1,amount_pop),...
    pop_array_field_1{11},cell(1,amount_pop),...
    pop_array_field_1{12},cell(1,amount_pop),...
    pop_array_field_1{13},cell(1,amount_pop),...
    pop_array_field_1{14},cell(1,amount_pop)...
    );

%initialize the field as zero
for cnt_1=1:1:amount_pop
    pop_array(cnt_1).obj_1=0;
    pop_array(cnt_1).obj_2=0;
    pop_array(cnt_1).pst_x_1=zeros(1,amount_airship);
    pop_array(cnt_1).pst_y_1=zeros(1,amount_airship);
    pop_array(cnt_1).pst_x_2=zeros(1,amount_airship);
    pop_array(cnt_1).pst_y_2=zeros(1,amount_airship);
    pop_array(cnt_1).w1=0;
    pop_array(cnt_1).w2=0;
    pop_array(cnt_1).nb=zeros(1,amount_neighbor);
    pop_array(cnt_1).obj_norm_1=0;
    pop_array(cnt_1).obj_norm_2=0;
    pop_array(cnt_1).obj_decomp=0;
end

%initialize the position
for cnt_1=1:1:amount_pop
    for cnt_2=1:1:amount_airship
        while (...
                (pop_array(cnt_1).pst_x_1(cnt_2)==0)||...
                (pop_array(cnt_1).pst_x_1(cnt_2)==area_x)||...
                (pop_array(cnt_1).pst_y_1(cnt_2)==0)||...
                (pop_array(cnt_1).pst_y_1(cnt_2)==area_y)||...
                (pop_array(cnt_1).pst_x_2(cnt_2)==0)||...
                (pop_array(cnt_1).pst_x_2(cnt_2)==area_x)||...
                (pop_array(cnt_1).pst_y_2(cnt_2)==0)||...
                (pop_array(cnt_1).pst_y_2(cnt_2)==area_y))
            pop_array(cnt_1).pst_x_1(cnt_2)=area_x*rand();
            pop_array(cnt_1).pst_y_1(cnt_2)=area_y*rand();
            pop_array(cnt_1).pst_x_2(cnt_2)=area_x*rand();
            pop_array(cnt_1).pst_y_2(cnt_2)=area_y*rand();
        end
    end
end

%initialize the weight vector
for cnt_1=1:1:amount_pop
    tmp_1=rand()*pi/2;
    pop_array(cnt_1).w1=sin(tmp_1)/(sin(tmp_1)+cos(tmp_1));
    pop_array(cnt_1).w2=1-pop_array(cnt_1).w1;
end

%initialize the neighborhood of the population
dist_w=zeros(amount_pop,amount_pop);
for cnt_1=1:1:amount_pop  %calculate the distance between any two weight vectors
    for cnt_2=cnt_1:1:amount_pop
        if cnt_1==cnt_2
            dist_w(cnt_1,cnt_2)=0;
        else
            dist_w(cnt_1,cnt_2)=(pop_array(cnt_1).w1-pop_array(cnt_2).w1).^2+(pop_array(cnt_1).w2-pop_array(cnt_2).w2).^2;
        end
    end
end
for cnt_1=1:1:amount_pop  %dumplicate the information
    for cnt_2=1:1:cnt_1
        if cnt_1~=cnt_2
            dist_w(cnt_1,cnt_2)=dist_w(cnt_2,cnt_1);
        end
    end
end
[tmp_1,tmp_2]=sort(dist_w,2);  %#ok<ASGLU> sort the distance matrix
for cnt_1=1:1:amount_pop  %record the neighbor indexes
    pop_array(cnt_1).nb=tmp_2(cnt_1,1:amount_neighbor);
end

end